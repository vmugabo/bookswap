rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Books collection: public read, authenticated users can create
    // a book document only if the ownerId equals their uid. Updates
    // and deletes are only allowed by the owner.
    match /books/{bookId} {
      allow read: if true;

      allow create: if request.auth != null
        && request.resource.data.keys().hasAll(['title','author','condition','imageUrl','ownerId','createdAt'])
        && request.resource.data.ownerId == request.auth.uid
        && request.resource.data.title is string
        && request.resource.data.author is string
        && request.resource.data.condition is string
        && (request.resource.size() < 64 * 1024); // roughly limit doc size

      allow update, delete: if request.auth != null
        && resource.data.ownerId == request.auth.uid;
    }

    // Users collection: users may read basic profiles, but may only
    // write their own profile document.
    match /users/{userId} {
      allow read: if true;
      allow create: if request.auth != null && request.auth.uid == userId;
      allow update: if request.auth != null && request.auth.uid == userId;
    }

    // Offers (swap requests): only involved parties can create and update their offers.
    match /offers/{offerId} {
      allow read: if request.auth != null
        && (resource.data.fromUserId == request.auth.uid || resource.data.toUserId == request.auth.uid);

      allow create: if request.auth != null
        && request.resource.data.keys().hasAll(['bookId','fromUserId','toUserId','status','createdAt'])
        && request.resource.data.fromUserId == request.auth.uid;

      allow update: if request.auth != null
        && (resource.data.fromUserId == request.auth.uid || resource.data.toUserId == request.auth.uid);

      allow delete: if false;
    }

    // Chats and messages: only participants may read or write.
    match /chats/{chatId} {
      allow read: if request.auth != null && resource.data.participants is list && request.auth.uid in resource.data.participants;

      allow create: if request.auth != null
        && request.resource.data.keys().hasAll(['chatId','participants','updatedAt'])
        && request.resource.data.participants is list
        && request.auth.uid in request.resource.data.participants;

      allow update: if request.auth != null && resource.data.participants is list && request.auth.uid in resource.data.participants;

      // messages subcollection
      match /messages/{messageId} {
        allow read: if request.auth != null &&
          (get(/databases/$(database)/documents/chats/$(chatId)).data.participants is list) &&
          request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;

        allow create: if request.auth != null
          && request.resource.data.keys().hasAll(['from','text','createdAt'])
          && request.resource.data.from == request.auth.uid
          && (get(/databases/$(database)/documents/chats/$(chatId)).data.participants is list)
          && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;

        // no arbitrary updates or deletes of messages
        allow update, delete: if false;
      }
    }

    // Fallback: deny writes by default, allow reads for public collections
    match /{document=**} {
      allow read: if true;
      allow write: if false;
    }
  }
}
